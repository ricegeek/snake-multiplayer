<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Retro Snakes - Collaborative Apple Hunt</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        body {
            background: #0a0a1a;
            color: #e0e0ff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            padding: 10px;
        }
        
        .container {
            width: 100%;
            max-width: 800px;
            padding: 15px;
        }
        
        .screen {
            display: none;
            text-align: center;
            padding: 20px;
            background: rgba(10, 10, 30, 0.8);
            border: 2px solid #4a4aff;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(74, 74, 255, 0.5);
            width: 100%;
            max-width: 500px;
        }
        
        .active {
            display: block;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 15px;
            color: #ff4a4a;
            text-shadow: 0 0 10px rgba(255, 74, 74, 0.7);
            letter-spacing: 2px;
        }
        
        h2 {
            font-size: 1.8rem;
            margin: 15px 0;
            color: #4aff4a;
            text-shadow: 0 0 10px rgba(74, 255, 74, 0.7);
        }
        
        .btn {
            background: #4a4aff;
            color: white;
            border: none;
            padding: 14px 25px;
            font-size: 1.1rem;
            border-radius: 8px;
            cursor: pointer;
            margin: 12px 8px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
            width: 80%;
            max-width: 250px;
            box-shadow: 0 4px 0 #2a2a8f;
        }
        
        .btn:hover {
            background: #6a6aff;
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #2a2a8f;
        }
        
        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #2a2a8f;
        }
        
        .btn:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 0 #333;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
            width: 100%;
        }
        
        .control-card {
            height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(30, 30, 60, 0.7);
            border: 2px solid #4a4aff;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            padding: 10px;
        }
        
        .control-card.selected {
            background: rgba(74, 74, 255, 0.3);
            border-color: #ff4a4a;
            box-shadow: 0 0 15px rgba(255, 74, 74, 0.5);
        }
        
        .control-card:hover:not(.selected) {
            background: rgba(50, 50, 90, 0.8);
            transform: scale(1.03);
        }
        
        .control-icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }
        
        .control-label {
            font-size: 1rem;
            font-weight: bold;
        }
        
        .game-container {
            position: relative;
            margin: 15px auto;
            border: 3px solid #4a4aff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(74, 74, 255, 0.5);
            width: 100%;
            max-width: 400px;
            aspect-ratio: 3/2;
        }
        
        canvas {
            background: #000;
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            font-size: 1.1rem;
            padding: 0 10px;
        }
        
        .players-info {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 15px 0;
            max-height: 180px;
            overflow-y: auto;
            padding: 5px;
        }
        
        .player-indicator {
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
            font-size: 1rem;
        }
        
        .player-1 { background: rgba(255, 74, 74, 0.3); }
        .player-2 { background: rgba(74, 255, 74, 0.3); }
        .player-3 { background: rgba(74, 74, 255, 0.3); }
        .player-4 { background: rgba(255, 255, 74, 0.3); }
        
        .instructions {
            background: rgba(20, 20, 40, 0.7);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: left;
            line-height: 1.5;
            font-size: 0.95rem;
        }
        
        .instructions h3 {
            color: #4aff4a;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .instructions ul {
            padding-left: 20px;
            margin: 10px 0;
        }
        
        .instructions li {
            margin: 6px 0;
        }
        
        .retro-scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                to bottom,
                transparent,
                transparent 1px,
                rgba(0, 0, 0, 0.1) 1px,
                rgba(0, 0, 0, 0.1) 2px
            );
            pointer-events: none;
            z-index: 10;
        }
        
        .share-section {
            margin: 15px 0;
            padding: 15px;
            background: rgba(30, 30, 60, 0.5);
            border-radius: 10px;
        }
        
        .share-url {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #4a4aff;
            border-radius: 8px;
            color: #e0e0ff;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            font-size: 0.9rem;
        }
        
        .status-message {
            margin: 12px 0;
            padding: 12px;
            background: rgba(74, 255, 74, 0.2);
            border-radius: 8px;
            font-weight: bold;
            font-size: 1rem;
        }
        
        .error-message {
            background: rgba(255, 74, 74, 0.2);
        }
        
        .waiting-message {
            background: rgba(255, 255, 74, 0.2);
        }
        
        /* Mobile-specific adjustments */
        @media (max-width: 500px) {
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
            .control-card { height: 85px; }
            .control-icon { font-size: 1.8rem; }
            .btn { padding: 12px; font-size: 1rem; }
            .player-indicator { padding: 8px; font-size: 0.95rem; }
        }
        
        /* iOS-specific fixes */
        @supports (-webkit-touch-callout: none) {
            .btn {
                -webkit-appearance: none;
            }
        }
        
        /* Android-specific fixes */
        @media screen and (min-width: 0) {
            input[type="text"] {
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
            }
        }
        
        /* Prevent zoom on input focus */
        input {
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Home Screen -->
        <div id="home-screen" class="screen active">
            <h1>RETRO SNAKES</h1>
            <p>Collaborative apple hunting with friends!</p>
            
            <div class="instructions">
                <h3>How to Play</h3>
                <ul>
                    <li>Create a game and share the link with friends</li>
                    <li>Each player controls one or more directions</li>
                    <li>Work together to collect apples</li>
                    <li>All 4 directions must be assigned to start</li>
                    <li>Play solo by assigning all directions to yourself!</li>
                </ul>
            </div>
            
            <button id="create-game-btn" class="btn">CREATE GAME</button>
        </div>
        
        <!-- Lobby Screen -->
        <div id="lobby-screen" class="screen">
            <h2>GAME LOBBY</h2>
            
            <div class="share-section">
                <h3>Share this link:</h3>
                <input type="text" id="game-url" class="share-url" readonly>
                <button id="copy-url-btn" class="btn">COPY LINK</button>
            </div>
            
            <div id="status-message" class="status-message"></div>
            
            <p>Assign directions to yourself</p>
            
            <div class="controls">
                <div class="control-card" data-direction="up">
                    <div class="control-icon">↑</div>
                    <div class="control-label">UP</div>
                </div>
                <div class="control-card" data-direction="down">
                    <div class="control-icon">↓</div>
                    <div class="control-label">DOWN</div>
                </div>
                <div class="control-card" data-direction="left">
                    <div class="control-icon">←</div>
                    <div class="control-label">LEFT</div>
                </div>
                <div class="control-card" data-direction="right">
                    <div class="control-icon">→</div>
                    <div class="control-label">RIGHT</div>
                </div>
            </div>
            
            <div class="players-info">
                <div class="player-indicator player-1">Player 1: Not Assigned</div>
                <div class="player-indicator player-2">Player 2: Not Assigned</div>
                <div class="player-indicator player-3">Player 3: Not Assigned</div>
                <div class="player-indicator player-4">Player 4: Not Assigned</div>
            </div>
            
            <button id="start-btn" class="btn" disabled>START GAME</button>
            <button id="back-btn" class="btn">BACK</button>
        </div>
        
        <!-- Game Screen -->
        <div id="game-screen" class="screen">
            <h2>APPLE HUNT</h2>
            
            <div class="game-container">
                <canvas id="game-canvas"></canvas>
                <div class="retro-scanlines"></div>
            </div>
            
            <div class="status-bar">
                <div>Apples: <span id="score">0</span></div>
                <div>Players: <span id="player-count">0</span>/4</div>
            </div>
            
            <button id="restart-btn" class="btn">RESTART</button>
        </div>
    </div>

    <script>
        // Mobile-friendly game state
        const gameState = {
            screen: 'home',
            gameId: null,
            isOwner: false,
            playerId: 1,
            selectedDirections: {},
            score: 0,
            gameRunning: false,
            snake: [],
            apple: {x: 0, y: 0},
            direction: 'right',
            lastDirection: 'right',
            gridSize: 20,
            gameSpeed: 150, // Slightly slower for mobile
            canvasSize: { width: 400, height: 266 } // 3:2 aspect ratio
        };
        
        // DOM Elements
        const screens = {
            home: document.getElementById('home-screen'),
            lobby: document.getElementById('lobby-screen'),
            game: document.getElementById('game-screen')
        };
        
        const buttons = {
            createGame: document.getElementById('create-game-btn'),
            start: document.getElementById('start-btn'),
            back: document.getElementById('back-btn'),
            restart: document.getElementById('restart-btn'),
            copyUrl: document.getElementById('copy-url-btn')
        };
        
        const controlCards = document.querySelectorAll('.control-card');
        const playerIndicators = document.querySelectorAll('.player-indicator');
        const scoreElement = document.getElementById('score');
        const playerCountElement = document.getElementById('player-count');
        const gameUrlInput = document.getElementById('game-url');
        const statusMessage = document.getElementById('status-message');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size based on container
        function setupCanvas() {
            const container = canvas.parentElement;
            const displayWidth = container.clientWidth;
            const displayHeight = container.clientHeight;
            
            // Set actual canvas size (higher resolution)
            canvas.width = displayWidth * window.devicePixelRatio;
            canvas.height = displayHeight * window.devicePixelRatio;
            
            // Scale context to match display size
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        
        // Generate a unique game ID
        function generateGameId() {
            return Math.random().toString(36).substring(2, 10);
        }
        
        // Update URL with game ID
        function updateUrl(gameId) {
            const url = new URL(window.location);
            url.searchParams.set('game', gameId);
            window.history.pushState({}, '', url);
            gameUrlInput.value = url.toString();
        }
        
        // Initialize game
        function initGame(isOwner = false) {
            gameState.isOwner = isOwner;
            gameState.playerId = 1;
            gameState.selectedDirections = {};
            gameState.score = 0;
            gameState.gameRunning = false;
            gameState.direction = 'right';
            gameState.lastDirection = 'right';
            
            // Reset UI
            controlCards.forEach(card => {
                card.classList.remove('selected');
            });
            
            playerIndicators.forEach(indicator => {
                indicator.textContent = `${indicator.textContent.split(':')[0]}: Not Assigned`;
            });
            
            buttons.start.disabled = true;
            scoreElement.textContent = '0';
            playerCountElement.textContent = '0';
            statusMessage.textContent = '';
            statusMessage.className = 'status-message';
        }
        
        // Show screen
        function showScreen(screenName) {
            Object.values(screens).forEach(screen => screen.classList.remove('active'));
            screens[screenName].classList.add('active');
            gameState.screen = screenName;
            
            if (screenName === 'game') {
                setupCanvas();
                startGame();
            }
        }
        
        // Assign direction to current player
        function assignDirection(direction) {
            if (gameState.selectedDirections[direction]) {
                delete gameState.selectedDirections[direction];
                statusMessage.textContent = `Unassigned ${direction.toUpperCase()}`;
            } else {
                gameState.selectedDirections[direction] = gameState.playerId;
                statusMessage.textContent = `Assigned ${direction.toUpperCase()} to Player ${gameState.playerId}`;
            }
            
            const card = document.querySelector(`.control-card[data-direction="${direction}"]`);
            if (gameState.selectedDirections[direction]) {
                card.classList.add('selected');
            } else {
                card.classList.remove('selected');
            }
            
            updatePlayerIndicators();
            
            const assignedCount = Object.keys(gameState.selectedDirections).length;
            playerCountElement.textContent = assignedCount;
            
            if (assignedCount === 4) {
                buttons.start.disabled = false;
                statusMessage.textContent = 'All directions assigned! Tap START to begin.';
                statusMessage.className = 'status-message';
            } else {
                buttons.start.disabled = true;
                statusMessage.className = 'status-message';
            }
        }
        
        // Update player indicators
        function updatePlayerIndicators() {
            playerIndicators.forEach(indicator => {
                indicator.textContent = `${indicator.textContent.split(':')[0]}: Not Assigned`;
            });
            
            const playerDirections = {};
            for (const [direction, playerId] of Object.entries(gameState.selectedDirections)) {
                if (!playerDirections[playerId]) {
                    playerDirections[playerId] = [];
                }
                playerDirections[playerId].push(direction.toUpperCase());
            }
            
            for (const [playerId, directions] of Object.entries(playerDirections)) {
                const indicator = playerIndicators[playerId - 1];
                indicator.textContent = `Player ${playerId}: ${directions.join(', ')}`;
            }
        }
        
        // Event Listeners
        buttons.createGame.addEventListener('click', () => {
            gameState.gameId = generateGameId();
            updateUrl(gameState.gameId);
            initGame(true);
            showScreen('lobby');
        });
        
        buttons.back.addEventListener('click', () => {
            showScreen('home');
        });
        
        buttons.restart.addEventListener('click', () => {
            showScreen('lobby');
        });
        
        buttons.copyUrl.addEventListener('click', () => {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(gameUrlInput.value).then(() => {
                    statusMessage.textContent = 'Link copied to clipboard!';
                    statusMessage.className = 'status-message';
                }).catch(() => {
                    fallbackCopyTextToClipboard(gameUrlInput.value);
                });
            } else {
                fallbackCopyTextToClipboard(gameUrlInput.value);
            }
        });
        
        // Fallback copy for older browsers
        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.left = "-999999px";
            textArea.style.top = "-999999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    statusMessage.textContent = 'Link copied to clipboard!';
                    statusMessage.className = 'status-message';
                } else {
                    statusMessage.textContent = 'Failed to copy. Please copy manually.';
                    statusMessage.className = 'status-message error-message';
                }
            } catch (err) {
                statusMessage.textContent = 'Failed to copy. Please copy manually.';
                statusMessage.className = 'status-message error-message';
            }
            document.body.removeChild(textArea);
        }
        
        // Control selection
        controlCards.forEach(card => {
            card.addEventListener('click', (e) => {
                e.preventDefault();
                const direction = card.dataset.direction;
                assignDirection(direction);
            });
        });
        
        buttons.start.addEventListener('click', () => {
            if (Object.keys(gameState.selectedDirections).length === 4) {
                showScreen('game');
            }
        });
        
        // Handle URL parameters
        window.addEventListener('load', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const gameId = urlParams.get('game');
            
            if (gameId) {
                gameState.gameId = gameId;
                gameUrlInput.value = window.location.href;
                initGame(false);
                showScreen('lobby');
                statusMessage.textContent = 'Joined game! Assign directions to control.';
                statusMessage.className = 'status-message';
            }
        });
        
        // Handle browser navigation
        window.addEventListener('popstate', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const gameId = urlParams.get('game');
            
            if (gameId) {
                gameState.gameId = gameId;
                gameUrlInput.value = window.location.href;
                initGame(false);
                showScreen('lobby');
                statusMessage.textContent = 'Joined game! Assign directions to control.';
                statusMessage.className = 'status-message';
            } else {
                showScreen('home');
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (gameState.screen === 'game') {
                setupCanvas();
                drawGame();
            }
        });
        
        // Game functions
        function initSnake() {
            const centerX = Math.floor(gameState.canvasSize.width / 2 / gameState.gridSize);
            const centerY = Math.floor(gameState.canvasSize.height / 2 / gameState.gridSize);
            gameState.snake = [
                {x: centerX, y: centerY},
                {x: centerX - 1, y: centerY},
                {x: centerX - 2, y: centerY}
            ];
        }
        
        function generateApple() {
            const maxX = Math.floor(gameState.canvasSize.width / gameState.gridSize) - 1;
            const maxY = Math.floor(gameState.canvasSize.height / gameState.gridSize) - 1;
            
            let newApple;
            let onSnake;
            
            do {
                onSnake = false;
                newApple = {
                    x: Math.floor(Math.random() * maxX),
                    y: Math.floor(Math.random() * maxY)
                };
                
                for (const segment of gameState.snake) {
                    if (segment.x === newApple.x && segment.y === newApple.y) {
                        onSnake = true;
                        break;
                    }
                }
            } while (onSnake);
            
            gameState.apple = newApple;
        }
        
        function drawSnake() {
            for (let i = 0; i < gameState.snake.length; i++) {
                const segment = gameState.snake[i];
                const isHead = i === 0;
                
                ctx.fillStyle = isHead ? '#ff4a4a' : '#4a4aff';
                ctx.fillRect(
                    segment.x * gameState.gridSize, 
                    segment.y * gameState.gridSize, 
                    gameState.gridSize, 
                    gameState.gridSize
                );
                
                ctx.strokeStyle = '#000';
                ctx.strokeRect(
                    segment.x * gameState.gridSize, 
                    segment.y * gameState.gridSize, 
                    gameState.gridSize, 
                    gameState.gridSize
                );
            }
        }
        
        function drawApple() {
            ctx.fillStyle = '#4aff4a';
            ctx.beginPath();
            ctx.arc(
                gameState.apple.x * gameState.gridSize + gameState.gridSize/2,
                gameState.apple.y * gameState.gridSize + gameState.gridSize/2,
                gameState.gridSize/2 - 2,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            ctx.fillStyle = '#aaffaa';
            ctx.beginPath();
            ctx.arc(
                gameState.apple.x * gameState.gridSize + gameState.gridSize/3,
                gameState.apple.y * gameState.gridSize + gameState.gridSize/3,
                gameState.gridSize/6,
                0,
                Math.PI * 2
            );
            ctx.fill();
        }
        
        function moveSnake() {
            if (!gameState.gameRunning) return;
            
            const head = {...gameState.snake[0]};
            
            switch(gameState.direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }
            
            const maxX = gameState.canvasSize.width / gameState.gridSize;
            const maxY = gameState.canvasSize.height / gameState.gridSize;
            
            if (head.x < 0 || head.x >= maxX || head.y < 0 || head.y >= maxY) {
                endGame();
                return;
            }
            
            for (let i = 0; i < gameState.snake.length; i++) {
                if (gameState.snake[i].x === head.x && gameState.snake[i].y === head.y) {
                    endGame();
                    return;
                }
            }
            
            gameState.snake.unshift(head);
            
            if (head.x === gameState.apple.x && head.y === gameState.apple.y) {
                gameState.score++;
                scoreElement.textContent = gameState.score;
                generateApple();
            } else {
                gameState.snake.pop();
            }
            
            gameState.lastDirection = gameState.direction;
        }
        
        function drawGame() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, gameState.canvasSize.width, gameState.canvasSize.height);
            
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 0.5;
            for (let x = 0; x < gameState.canvasSize.width; x += gameState.gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, gameState.canvasSize.height);
                ctx.stroke();
            }
            for (let y = 0; y < gameState.canvasSize.height; y += gameState.gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(gameState.canvasSize.width, y);
                ctx.stroke();
            }
            
            drawApple();
            drawSnake();
        }
        
        function gameLoop() {
            moveSnake();
            drawGame();
            
            if (gameState.gameRunning) {
                setTimeout(gameLoop, gameState.gameSpeed);
            }
        }
        
        function startGame() {
            // Set canvas size based on actual display
            const container = canvas.parentElement;
            gameState.canvasSize.width = container.clientWidth;
            gameState.canvasSize.height = container.clientHeight;
            
            initSnake();
            generateApple();
            gameState.gameRunning = true;
            playerCountElement.textContent = '4';
            setupCanvas();
            gameLoop();
        }
        
        function endGame() {
            gameState.gameRunning = false;
            setTimeout(() => {
                if (confirm(`Game Over! You collected ${gameState.score} apples!\nPlay again?`)) {
                    showScreen('lobby');
                } else {
                    showScreen('home');
                }
            }, 100);
        }
        
        // Touch controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            if (gameState.screen !== 'game') return;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault();
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            if (gameState.screen !== 'game') return;
            e.preventDefault();
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            if (gameState.screen !== 'game') return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            
            // Determine swipe direction
            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal swipe
                if (dx > 20 && gameState.lastDirection !== 'left') {
                    gameState.direction = 'right';
                } else if (dx < -20 && gameState.lastDirection !== 'right') {
                    gameState.direction = 'left';
                }
            } else {
                // Vertical swipe
                if (dy > 20 && gameState.lastDirection !== 'up') {
                    gameState.direction = 'down';
                } else if (dy < -20 && gameState.lastDirection !== 'down') {
                    gameState.direction = 'up';
                }
            }
            
            e.preventDefault();
        }, { passive: false });
        
        // Keyboard controls (for desktop testing)
        document.addEventListener('keydown', (e) => {
            if (gameState.screen !== 'game') return;
            
            if (e.key === 'ArrowUp' && gameState.lastDirection !== 'down') {
                gameState.direction = 'up';
            } else if (e.key === 'ArrowDown' && gameState.lastDirection !== 'up') {
                gameState.direction = 'down';
            } else if (e.key === 'ArrowLeft' && gameState.lastDirection !== 'right') {
                gameState.direction = 'left';
            } else if (e.key === 'ArrowRight' && gameState.lastDirection !== 'left') {
                gameState.direction = 'right';
            }
        });
    </script>
</body>
</html>
